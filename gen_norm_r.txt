# first did it this way, then 
generate.dataset.manual = function(n, p, b, R) {
  #' Generates a simulated dataset.
  #'
  #' @param n The number of observations.
  #' @param p The number of predictors.
  #' @param b The beta values for each predictor (must be a vector of length p)
  #' @param R The target correlation matrix for the predictors
  
  # make sure arguments are valid
  if (p != length(b)) stop('Must provide p values of beta')
  if (p != dim(R)[1]) stop('Must provide a p x p correlation matrix')
  
  # create uncorrelated predictors
  df = data.frame(do.call(cbind, lapply(1:p, function(i) rnorm(n, 0, 1))))
  print(df)
  
  # apply correlation (multiply by Cholesky decomp. of correlation matrix)
  # strategy adapted from https://stats.stackexchange.com/a/313148/338214
  nms = names(df)
  C = chol(R)
  X = data.matrix(df)
  df = as.data.frame(X %*% C)
  names(df) = nms
  
  # make sure correlations between generated predictors approximate target
  print(R)
  print(cor(df))
  
  # calculate response and attach to data frame
  df$Y = sum(sapply(1:p, function(i) b[i] * df[, i])) +   # predictor terms
         rnorm(n, 0, 1)                                   # error term
  # df$Y = b[1] * df$X1 + 
  #        b[2] * df$X2 + 
  #        b[3] * df$X3 + 
  #        b[4] * df$X4 + 
  #        b[5] * df$X5 + 
  #        b[6] * df$X6 + 
  #        b[7] * df$X7 + 
  #        b[8] * df$X8 + 
  #        rnorm(n, 0, 1) # error term
  
  df
}